package pattern

import "fmt"

/*
	Реализовать паттерн «фабричный метод».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Factory_method_pattern
*/

/*
Применимость:
1. Заранее неизвестно, объекты каких структур нужно создавать.
2. Нужно поддерживать добавление новых продуктов.
3. Код не должен зависеть от конкретных продуктов.

Плюсы:
1. Избавляет клиентский код от привязки к конкретным классам продуктов.
2. Упрощает добавление новых продуктов.

Минусы:
1. Усложняет код.
2. Параллельные иерархии классов.
*/

/*
Например нам нужно работать с разными отображениями пользовательских интерфейсов.
*/

// Графический пользовательский интерфейс
type GUI struct{}

func (u *GUI) Draw() {
	fmt.Println("fake gui")
}

// Текстовый пользовательский интерфейс
type TUI struct{}

func (u *TUI) Draw() {
	fmt.Println("fake tui")
}

// Интерфейс продукта
type UI interface {
	Draw()
}

// Фабричный метод может быть параметризированным, то есть клиент передает объект какого типа ему нужен.
// Либо быть в виде структурок удовлетворяющих интерфейс фабричного метода/функций
// Сдеаем в виде параметризированной функции
type UIType int

const (
	GUI_TYPE UIType = iota
	TUI_TYPE
)

// Фабричный метод
func UIFactory(t UIType) UI {
	switch t {
	case GUI_TYPE:
		return &GUI{}
	case TUI_TYPE:
		return &TUI{}
	}
	panic("wrong uitype")
}
